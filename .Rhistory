xmax <- max(s$x)
ymax <- max(s$y)
xmin <- min(s$x)
ymin <- min(s$y)
nAugmentation <-  4
fileOut<-"/home/jo/Documents/suiviTempMAB/data/capsis/ZE100_OK/saplingToTreeNHA30.txt"
id <- 1998+1
s$speciesId <- 3
for (i in 1:nrow(s)){
c <- s[i,]
newObs <- c[rep(row.names(c), times = nAugmentation), ]
newObs$x <- pmax(pmin(newObs$x+ rnorm(nAugmentation, mean=1, sd=1), rep(xmax,nAugmentation)), rep(xmin,nAugmentation))# pour rester dans l'enveloppe du peuplement
newObs$y <- pmax(pmin(newObs$y+ rnorm(nAugmentation, mean=1, sd=1), rep(ymax,nAugmentation)), rep(ymin,nAugmentation))
# la hauteur c'est dangereux de la modifier, car elle est plafonnée à 2.6m pour les saplings de ce peuplements
newObs$saplingHeight <- pmin(newObs$saplingHeight + rnorm(nAugmentation, mean=0.5, sd=1), rep(2.6,3))
newObs$id <- c(index0+1:nAugmentation)
s <- rbind(s, newObs)
index0 <- index0+nAugmentation
for (sapToTree in 1:nrow(newObs)){
cat(id,"3",newObs$x[sapToTree],newObs$y[sapToTree],"0.0	3	NA	NA	NA	NA	D	(0,0,0,0,0,0,0,0,0,0,0)	alive\n", sep="\t", append = TRUE, file=fileOut)
id <- id +1
}
}
s <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/ZE100_OK/saplingCH_NHA30.csv", sep="\t", dec=".")
index0 <- max(s$id)
xmax <- max(s$x)
ymax <- max(s$y)
xmin <- min(s$x)
ymin <- min(s$y)
nAugmentation <-  4
fileOut<-"/home/jo/Documents/suiviTempMAB/data/capsis/ZE100_OK/saplingToTreeNHA30.txt"
id <- 1998+1
s$speciesId <- 3
for (i in 1:nrow(s)){
c <- s[i,]
newObs <- c[rep(row.names(c), times = nAugmentation), ]
newObs$x <- pmax(pmin(newObs$x+ rnorm(nAugmentation, mean=1, sd=1), rep(xmax,nAugmentation)), rep(xmin,nAugmentation))# pour rester dans l'enveloppe du peuplement
newObs$y <- pmax(pmin(newObs$y+ rnorm(nAugmentation, mean=1, sd=1), rep(ymax,nAugmentation)), rep(ymin,nAugmentation))
# la hauteur c'est dangereux de la modifier, car elle est plafonnée à 2.6m pour les saplings de ce peuplements
newObs$saplingHeight <- pmin(newObs$saplingHeight + rnorm(nAugmentation, mean=0.5, sd=1), rep(2.6,3))
newObs$id <- c(index0+1:nAugmentation)
s <- rbind(s, newObs)
index0 <- index0+nAugmentation
for (sapToTree in 1:nrow(newObs)){
cat(id,"3",newObs$x[sapToTree],newObs$y[sapToTree],"0.0	6	NA	NA	NA	NA	D	(0,0,0,0,0,0,0,0,0,0,0)	alive\n", sep="\t", append = TRUE, file=fileOut)
id <- id +1
}
}
d <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaieAvecRegeChene_25ansB_inv1000_UE10.csv",dec = ".")
summary(d)
d <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaieAvecRegeChene_25ansB_inv1000_UE10.csv",dec = ".")
summary(d)
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)
spiders <- read_csv(file = "Spider Data.csv")
library(tidyverse)
help("boxplot")
boxplot(d$nha_miv, at=c(0.85,1.85), col=2, names="Good")
boxplot(d$nha_miv, at=c(1), col=2, names="Good")
boxplot(d$nha_miv, at=c(1), col=2, ylim=c(0,3))
boxplot(d$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(d$gha_miv, at=c(2), col=3, add=T)
p3 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaieAvecRegeChene_25ansB_inv1000_UE10.csv",dec = ".")
boxplot(d$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(d$gha_miv, at=c(8), col=3, add=T)
p1 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/ZE100_OK/pde_simBoulaie_inv1000_UE10.csv",dec = ".")
p1 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaie_inv1000_UE10.csv",dec = ".")
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
p1$nha_miv
View(p1)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
p1 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaie_inv1000_UE10.csv",dec = ".")
View(p1)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
boxplot(d$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
boxplot(d$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12), add=T)
boxplot(d$gha_miv, at=c(8), col=3, add=T)
abline(a=1)
abline(h=1)
abline(h=1, lwd=2)
abline(h=1, lwt=2)
help(abline)
boxplot(d$gha_miv, at=c(8), col=3, add=T)
abline(h=1, lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
boxplot(d$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12), add=T)
boxplot(d$gha_miv, at=c(8), col=3, add=T)
abline(h=1, lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12))
abline(h=1, lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12),add=T)
boxplot(p1$gha_miv, at=c(2), col=3, add=T)
boxplot(d$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12), add=T)
boxplot(d$gha_miv, at=c(8), col=3, add=T)
boxplot(p3$nha_miv, at=c(7), col=2, ylim=c(0,3), xlim=c(0,12), add=T)
boxplot(p3$gha_miv, at=c(8), col=3, add=T)
boxplot(p3$nha_rel_Bouleau, at=c(9), col="grey80", add=T)
boxplot(p3$gha_rel_Bouleau, at=c(10), col="grey90", add=T)
boxplot(p3$nha_rel_Chene, at=c(11), col="forestgreen", add=T)
boxplot(p3$gha_rel_Chene, at=c(12), col="forestgreen", add=T)
p3 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simChenaie_inv1000_UE10.csv",dec = ".")
View(p3)
p2 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simChenaie_inv1000_UE10.csv",dec = ".")
boxplot(p2$nha_miv, at=c(4), col=2, add=T)
boxplot(p2$gha_miv, at=c(5), col=3, add=T)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), lwt=0.5)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=0.5)
# cex pour réduire la taille des points
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=0.5)
abline(h=1, lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=0.5,add=T)
boxplot(p1$gha_miv, at=c(2), col=3, add=T, cex=0.5)
boxplot(p2$nha_miv, at=c(4), col=2, add=T, cex=0.5)
boxplot(p2$gha_miv, at=c(5), col=3, add=T, cex=0.5)
boxplot(p3$nha_miv, at=c(7), col=2, add=T, cex=0.5)
boxplot(p3$gha_miv, at=c(8), col=3, add=T, cex=0.5)
p3 <- read.csv2("/home/jo/Documents/suiviTempMAB/data/capsis/pde_simBoulaieAvecRegeChene_25ansB_inv1000_UE10.csv",dec = ".")
boxplot(p3$nha_miv, at=c(7), col=2, add=T, cex=0.5)
# cex pour réduire la taille des points
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=0.5)
abline(h=1, lty=2)
boxplot(p1$nha_miv, at=c(1), col=2, ylim=c(0,3), xlim=c(0,12), cex=0.5,add=T)
boxplot(p1$gha_miv, at=c(2), col=3, add=T, cex=0.5)
boxplot(p2$nha_miv, at=c(4), col=2, add=T, cex=0.5)
boxplot(p2$gha_miv, at=c(5), col=3, add=T, cex=0.5)
boxplot(p3$nha_miv, at=c(7), col=2, add=T, cex=0.5)
boxplot(p3$gha_miv, at=c(8), col=3, add=T, cex=0.5)
boxplot(p3$nha_rel_Bouleau, at=c(9), col="grey80", add=T, cex=0.5)
boxplot(p3$gha_rel_Bouleau, at=c(10), col="grey90", add=T, cex=0.5)
boxplot(p3$nha_rel_Chene, at=c(11), col="forestgreen", add=T)
boxplot(p3$gha_rel_Chene, at=c(12), col="forestgreen", add=T)
help(randomForest)
help("randomForest")
require(randomForest)
help("randomForest")
install.packages(snowfall)
install.packages("snowfall")
narray <- readRDS(inarray,"/home/jo/Documents/S2/dc_tool_out/sits/inarray.rds")
inarray <- readRDS("/home/jo/Documents/S2/dc_tool_out/sits/inarray.rds")
inarray
dates <- readRDS(,"/home/jo/Documents/S2/dc_tool_out/sits/dates.rds")
dates <- readRDS("/home/jo/Documents/S2/dc_tool_out/sits/dates.rds")
dates
sensors <- readRDS("/home/jo/Documents/S2/dc_tool_out/sensors.rds")
bandnames <- readRDS("/home/jo/Documents/S2/dc_tool_out/bandnames.rds")
sensors <- readRDS("/home/jo/Documents/S2/dc_tool_out/sits/sensors.rds")
sensors
bandnames <- readRDS("/home/jo/Documents/S2/dc_tool_out/sits/bandnames.rds")
bandnames
inarray <- readRDS("/home/jo/Documents/S2/dc_tool_out/inarray.rds")
dates <- readRDS("/home/jo/Documents/S2/dc_tool_out/dates.rds")
sensors <- readRDS("/home/jo/Documents/S2/dc_tool_out/sensors.rds")
bandnames <- readRDS("/home/jo/Documents/S2/dc_tool_out/bandnames.rds")
o <- impute_linear(t(c(inarray[,2], inarray[,1])/10000))
# global header, e.g., for loading libraries
library("sits")
o <- impute_linear(t(c(inarray[,2], inarray[,1])/10000))
o
out <-mod_tempcnn(o.ready)
# global header, e.g., for loading libraries
library("sits")
library("LDATS")
library("torch")
mod_tempcnn <-readRDS("/home/jo/Documents/S2/dc_tool_out/sits/tempcnn_csw_ndv.rds")
# PROTOTYPAGE pour BLOCK LEVEL - ça va aller très bien
inarray <- readRDS("/home/jo/Documents/S2/dc_tool_out/inarrayB.rds")
# ou c(3,4,1,2). Non ce qui est sur c'est que le 1, 2 est bon.
reshaped <- array( aperm(inarray[,2:1,,], c(3,4,1,2)) , dim =c( 250*500, 2*192) )/10000
px1 <- 158*500+249*250
test <- reshaped[px1,]
px1 <- 158*500+249
test <- reshaped[px1,]
test
# For Windows and Linux: "cpu", "cu124" are the only currently supported
# For MacOS the supported are: "cpu-intel" or "cpu-m1"
kind <- "cu124"
version <- available.packages()["torch","Version"]
options(repos = c(
torch = sprintf("https://torch-cdn.mlverse.org/packages/%s/%s/", kind, version),
CRAN = "https://cloud.r-project.org" # or any other from which you want to install the other R dependencies.
))
torch
options
repos
repos = c(
torch = sprintf("https://torch-cdn.mlverse.org/packages/%s/%s/", kind, version),
CRAN = "https://cloud.r-project.org" # or any other from which you want to install the other R dependencies.
)
repos
3*5
15+12
30/0.4
library(dplyr)
library(sf)
spCompo <- c("EP", "CH", "HE")
spRecommandation <- c("EP", "CHP", "HE")
seuilCompo <- c(80, 66, 66)
# on repart de la BD phyto IPRFW - voir rapport Cordier 2015 (financement OWSF)
require(RSQLite)
db.path <- "/home/jo/Documents/carteApt/catalogues/vulnerabilite2024/phyto4Pauline/Phyto_onlyIPRFW.db"
db <- dbConnect(SQLite(),dbname=db.path)
dbBegin(db)
pla <- dbReadTable(db ,"PLACETTE")
code_es_phyto <- c("quepet", "querob", "picabi", "fagsyl")
code_es_FEE <- c("CS", "CP", "EP", "HE")
num <- 1
ess_fee <- code_es_FEE[num]
ess_phyto <- code_es_phyto[num]
query <- paste0("  SELECT PLACETTE.id_plot,
PLACETTE_APTFEE.",ess_fee," as apt
FROM PLACETTE
LEFT JOIN PHYTO ON PLACETTE.id_plot = PHYTO.id_plot
LEFT JOIN PLACETTE_APTFEE ON PLACETTE_APTFEE.id_plot = PHYTO.id_plot
WHERE PHYTO.CODE_ES = '",ess_phyto,"' AND PHYTO.STRATE=3
GROUP BY PLACETTE.id_plot;")
apt <- dbGetQuery(db, query)
apt
shp.PLA <- st_as_sf(pla, coords = c("X", "Y"), crs = 31370)
pla$X
pla$x_ok <- as.numeric(pla$X)
as.numeric(pla$X)
as.numeric(sub(",", ".", pla$X, fixed = TRUE))
pla$x_ok <- as.numeric(sub(",", ".", pla$X, fixed = TRUE))
pla$y_ok <- as.numeric(sub(",", ".", pla$Y, fixed = TRUE))
shp.PLA <- st_as_sf(pla, coords = c("x_ok", "y_ok"), crs = 31370)
shp.prov <- st_read("/home/jo/Documents/carteApt/catalogues/vulnerabilite2024/phyto4Pauline/provincesRW/admi_provinces.shp)
""
)
")
shp.prov <- st_read("/home/jo/Documents/carteApt/catalogues/vulnerabilite2024/phyto4Pauline/provincesRW/admi_provinces.shp")
shp.prov$NOM_A_P=="LUXEMBOURG"
lux <- shp.prov[shp.prov$NOM_A_P=="LUXEMBOURG",]
lux
st_within(shp.PLA,lux)
st_crs(shp.PLA)
st_crs(lux)
st_crs(shp.prov) <- crs(31370)
st_crs(shp.prov) <- st_crs(31370)
st_within(shp.PLA,lux)
lux <- shp.prov[shp.prov$NOM_A_P=="LUXEMBOURG",]
st_within(shp.PLA,lux)
keep <- st_within(shp.PLA,lux)
keep
sum(keep)
pla.lux <- shp.PLA[keep]
as.matrix(keep)
pla.lux <- shp.PLA[as.matrix(keep)]
m<-  as.matrix(keep)
m<-  as.vector(keep)
m
m<-  as.matrix(keep)[,1]
pla.lux <- shp.PLA[as.matrix(keep)[,1]]
pla.lux <- shp.PLA[as.matrix(keep)[,1],]
pla.lux$IGN_NPL
d_plot
pla.lux$id_plot
apt.lux <- apt$apt[apt$id_plot %in% pla.lux$id_plot]
apt.lux
ess_fee
nrow(apt.lux)
dbClose(db)
dbDisconnect(db)
basedir <- "/home/jo/Documents/OGF/OGF_Wallonia_forest_plots"
setwd(basedir)
# script qui contient la ou les fonctions utilisées , ici le tarif de cubage.
source(paste0(basedir,"scripts/utils_OGF.R"))
# script qui contient la ou les fonctions utilisées , ici le tarif de cubage.
source(paste0(basedir,"/scripts/utils_OGF.R"))
db.path <- paste0(basedir,"/data/OGF_all.db")
db <- dbConnect(SQLite(),dbname=db.path)
require(RSQLite)
library(sf)
library(terra)
library(tools)
library("readxl")
library(dplyr)
# Open foris collect is used as form in a mobile application to collect all the dendrometric measurements, exept the one related to the GNSS
# We export open foris data from the server in csv format and then we integrate them in the sqlite database
# un dossier pour les entry, un pour les cleansing
path.entry.collect.list <- paste0("/home/jo/Documents/OGF/collect/collect-C-2025-12-12"))
# Open foris collect is used as form in a mobile application to collect all the dendrometric measurements, exept the one related to the GNSS
# We export open foris data from the server in csv format and then we integrate them in the sqlite database
# un dossier pour les entry, un pour les cleansing
path.entry.collect.list <- paste0("/home/jo/Documents/OGF/collect/collect-C-2025-12-12")
# quand on reçoit un nouvel encodage via le formulaire web, on l'ajoute à la bd OGF_all
path.ogf.encodage.toadd <- "/home/jo/Documents/OGF/data/OGF20251202.db"
db.path <- paste0(basedir,"/data/OGF_all.db")
db <- dbConnect(SQLite(),dbname=db.path)
# encodage via formulaire web
if (file.exists(path.ogf.encodage.toadd)){
dbNewOGF <- dbConnect(SQLite(),dbname=path.ogf.encodage.toadd)
new.ogf<- dbReadTable(dbNewOGF ,"ogf")
dbDisconnect(dbNewOGF)
dbWriteTable(db,"ogf",new.ogf, overwrite=T)
}
# check que tout les dictionnaires sont dans la BD. Si pas, je les ajoute
for (dico.file in list.files(path.dico.tables)){
if (!file_path_sans_ext(dico.file) %in% dbListTables(db)){
if ( file_ext(dico.file)=="xlsx"){
dico_table <- read_excel(paste0(path.dico.tables,"/",dico.file))
cat(paste("ajout table ", file_path_sans_ext(dico.file),"\n"))
dbWriteTable(db,file_path_sans_ext(dico.file),dico_table)
}
if ( file_ext(dico.file)=="csv"){
dico_table <- read.csv2(paste0(path.dico.tables,"/",dico.file))
cat(paste("ajout table ", file_path_sans_ext(dico.file),"\n"))
dbWriteTable(db,file_path_sans_ext(dico.file),dico_table)
}
}
}
# les dictionnaires on les ajoute à priori une seule fois
path.dico.tables <- "/home/jo/Documents/OGF/collect/dico"
# check que tout les dictionnaires sont dans la BD. Si pas, je les ajoute
for (dico.file in list.files(path.dico.tables)){
if (!file_path_sans_ext(dico.file) %in% dbListTables(db)){
if ( file_ext(dico.file)=="xlsx"){
dico_table <- read_excel(paste0(path.dico.tables,"/",dico.file))
cat(paste("ajout table ", file_path_sans_ext(dico.file),"\n"))
dbWriteTable(db,file_path_sans_ext(dico.file),dico_table)
}
if ( file_ext(dico.file)=="csv"){
dico_table <- read.csv2(paste0(path.dico.tables,"/",dico.file))
cat(paste("ajout table ", file_path_sans_ext(dico.file),"\n"))
dbWriteTable(db,file_path_sans_ext(dico.file),dico_table)
}
}
}
# check que toutes les données terrain encodées avec collect sont dans la BD.
for (path.entry.collect in path.entry.collect.list){
if (file.exists(path.entry.collect)){
for (entry.file in list.files(path.entry.collect)){
# si la table n'existe pas, on l'ajoute.
entry_table <- read.csv2(paste0(path.entry.collect,"/",entry.file), sep=",", dec=".")
if (file_ext(entry.file)=="csv" & !file_path_sans_ext(entry.file) %in% dbListTables(db)){
dbWriteTable(db,file_path_sans_ext(entry.file),entry_table)
cat(paste("ajout de la table ", file_path_sans_ext(entry.file),"\n"))
} else {
# si la table existe, on vérifie que toute les observations y sont déjà - sinon ajout
entry.db <- dbReadTable(db ,file_path_sans_ext(entry.file))
new.record <- setdiff(entry_table,entry.db[colnames(entry.db) %in% colnames(entry_table)])
if (nrow(new.record)>0){
# ajout des colonnes qui ne sont pas présentent dans "collect"
for (newcol in colnames(entry.db)[!colnames(entry.db) %in% colnames(entry_table)]){
new.record$newcol <- 0
if (newcol=="A5"){new.record$newcol <- 1}
colnames(new.record)[ncol(new.record)] <- newcol
}
cat(paste("ajout ",nrow(new.record), " observations dans table ", file_path_sans_ext(entry.file),"\n"))
dbWriteTable(db,file_path_sans_ext(entry.file),new.record,append=T)
}
}
}
} else {
cat(paste0("directory ", path.entry.collect, " does not exist\n"))
}
}
ogf<- dbReadTable(db ,"ogf")
dico_cubage<- dbReadTable(db ,"dico_cubage")
dico_cubage_branche<- dbReadTable(db ,"dico_cubage_branche")
dico_ess_cub<- dbReadTable(db ,"dico_essence_cubage")
dico_ess<- dbReadTable(db ,"essence_list")
arbre<- dbReadTable(db ,"arbre")
cohorte <- dbReadTable(db ,"cohorte_arbre")
ues <- dbReadTable(db ,"ues")
# check qu'il y ai bien une seule ligne par UE
if(nrow(unique(ues[,c("id_ue", "id_ogf")]))!=nrow(ues)){
cat("vérifier la table ues, certaines placettes apparaissent en doublons")
}
dt_FAS <- dbReadTable(db ,"bois_mort_placette")
dt_LIS <- dbReadTable(db ,"bois_mort_transect")
# FAS is realized on the 18m plot. logs > 90 cm
dt_FAS <- dbReadTable(db ,"bois_mort_placette")
# LIS is realized for 3 transects of 27 meters. 30 cm < logs < 90 cm
dt_LIS <- dbReadTable(db ,"bois_mort_transect")
dendro <- dbReadTable(db ,"dendro")
ue_gnss <- dbReadTable(db ,"ue_gnss")
ue_date <- as.Date(paste(ues$date_year,ues$date_month, ues$date_day,sep="-"))
ues$lLIS <- 27
ues$lLIS[ue_date < as.Date("2025-12-1")] <- 15
arbre$A5bool <- arbre$a5=="true"
# calcul du volume des arbres sur pied
arbre$v <- 0
arbre$v_branches <- 0
for (i in 1:nrow(arbre)){
arbre$v_branches[i] <- vBranches(arbre$circ[i],dico_ess_cub$numtarif[dico_ess_cub$abreviation == arbre$ess[i]])
# arbre vivant
if (arbre$statut[i]==1){
arbre$v_tc1[i] <- tc( arbre$circ[i],dico_ess_cub$numtarif[dico_ess_cub$abreviation == arbre$ess[i]])
} else {
# arbre mort sur pied: soit c'est une chandelle et j'ai sa hauteur pour le cubage, soit j'ai encore le houppier et je cube comme pour un arbre vivant.
arbre$v_branches[i] <- vBranches(arbre$circ[i],dico_ess_cub$numtarif[dico_ess_cub$abreviation == arbre$ess[i]])
# identification des chandelles pour la première partie de l'inventaire ; je devrais comparer la hauteur prédite par allométrie avec celle mesurée.
if (!is.na(arbre$h[i])){
if (arbre$h[i]>15){
arbre$v_tc1[i] <- tc( arbre$circ[i],dico_ess_cub$numtarif[dico_ess_cub$abreviation == arbre$ess[i]])
} else {
# cylindre : pi r2 * h
arbre$v[i] <- ((arbre$circ[i]/100)^2)/(4*pi) * arbre$h[i]
arbre$v_branches[i] <-0
}
} else {
cat(paste("Pas de hauteur pour arbre mort numéro", i," de ", arbre$circ[i] , " de tour, ogf ",arbre$ues_id_ogf[i], " ue ", arbre$ues_id_ue[i], " \n"))
arbre$v_tc1[i] <- tc( arbre$circ[i],dico_ess_cub$numtarif[dico_ess_cub$abreviation == arbre$ess[i]])
}
# si j'ai un crownVolumeReduction renseigné, je l'applique
if (!is.na(arbre$cvr[i]) & arbre$cvr[i]>0){
arbre$v_branches[i] <- arbre$v_branches[i]*(1-arbre$cvr[i]/100)
}
}
}
arbre$v[arbre$v==0 & !is.na(arbre$v_tc1)] <- arbre$v_tc1[arbre$v==0 & !is.na(arbre$v_tc1)] + arbre$v_branches[arbre$v==0 & !is.na(arbre$v_tc1)]
# facteur d'extension pour les 3 parcelles concentriques - arbres vivants
feA3 <- 10000/(pi*9^2)
feA4 <- 10000/(pi*18^2)
feA5 <- 10000/(pi*30^2)
arbre$fe[arbre$statut==1  & arbre$circ>=240] <- feA5 # A5
arbre$fe[arbre$statut==1  & arbre$circ>=120 & arbre$circ<240] <- feA4   # A4
arbre$fe[arbre$statut==1  & arbre$circ<120] <- feA3 # A3
arbre$fe[arbre$A5bool==0] <- 0 # pour repérer les arbres dominants de moins de 240 de tour qu'on a mesuré à une distance de plus de 18 mètres du centre de placette
# facteur d'extension pour les arbres mort sur pied : il sont pris dans la placette de 30 mètres de rayon - et ce n'est pas le même seuil d'inventaire que pour les vivants : 30 cm de circ plutôt que 40
arbre$fe[arbre$statut==2  & arbre$circ>=40] <- feA5
arbre$fe[arbre$statut==2  & arbre$circ<40] <- 0
dbWriteTable(db,"arbre",arbre, overwrite=T)
for (i in 1:nrow(cohorte)){
# je n'ai pas l'essence, donc il me faut une essence par défaut pour le tarif de cubage. Feuillus divers
if (cohorte$grosseur[i]==1){
cohorte$circ[i] <- 30
cohorte$v[i] <- 0 # car sous le seuil d'inventaire des IFA "classique"
} else {
cohorte$circ[i] <- cohorte$grosseurs[i]*40-20
cohorte$v[i] <- cohorte$nombre[i] * tc(cohorte$circ[i],11)
}
}
dt_FAS$v <- (pi*(dt_FAS$longueur)/2)*((dt_FAS$circ1/(pi*200))^2 +(dt_FAS$circ2/(pi*200))^2)
# calcul du volume des arbres mort au sol LIS, Van Wagner 1968
# en m3/m2 :  v <- pi^2/8*(Longeur) diameter^2
key_ue_cols <- c("ues_id_ogf", "ues_id_ue")
key_ue_cols2 <- c("id_ogf", "id_ue")
lLIS <- merge(dt_LIS,ues[,c(key_ue_cols2,"lLIS")],by.x=key_ue_cols, by.y=key_ue_cols2 , all=F)
# une branche de 76 de tour compte pour 16 m2 / ha si les transects font 15m... ça monte vite donc.
# dans metadata de vandeKerkhove -> volume of lying deadwood per ha (m³/ha);  small fragments excluded (diameter < 10 cm or length < 1m; if diameter > 20 cm, length < 0,5m)
dt_LIS$v <- 10000 * ((pi^2)/(8*(3*lLIS$lLIS)))*(dt_LIS$circ/(pi*100))^2
# les noms des variables dendro se rapprochent autant que ce peux de celles utilisées par Vandekerkhove
dendro_arbre_vivant <- arbre[arbre$statut==1,] %>% group_by(ues_id_ogf,ues_id_ue) %>% summarise(number_of_trees_thres120=sum(fe),vol_alive_thres120 = sum(v_tc1*fe), basal_area_alive_thres120=sum((circ/100)^2*fe/(4*pi)))
dendro_arbre_mort <- arbre[arbre$statut==2,] %>% group_by(ues_id_ogf,ues_id_ue) %>% summarise(vol_dead_standing = sum((v)*fe), basal_area_dead=sum((circ/100)^2*fe/(4*pi)))
dendro_cohorte <- cohorte %>% group_by(ues_id_ogf,ues_id_ue) %>% summarise(number_of_trees_co=sum(nombre*feA3), vol_alive_co = sum(v*feA3), basal_area_alive_co=sum(nombre*(circ/100)^2*feA3/(4*pi)))
dendro_FAS <- dt_FAS %>% group_by(ues_id_ogf,ues_id_ue) %>% summarise(vol_log_FAS = sum(v*feA4))
dendro_LIS <- dt_LIS %>% group_by(ues_id_ogf,ues_id_ue) %>% summarise(vol_log_LIS = sum(v))
#création matrice ogf x essence pour proportion de chaque essence dans l'UE
e <- unique(arbre$ess)
# check que les code essences sont dans le dictionnaire
#e[!e %in% dico_ess$essence_code]
gha_rel <- data.frame(matrix(0,ncol=2+length(e),nrow=nrow(ues), dimnames=list(NULL,c(key_ue_cols, e))))
gha_rel[,key_ue_cols] <- ues[, c("id_ogf", "id_ue")]
# un gha par essence
gha_ess <- arbre[arbre$statut==1,] %>% group_by(ues_id_ogf,ues_id_ue, ess) %>% summarise(gha_rel = sum((circ/100)^2*fe/(4*pi)))
# on divise par le gha (presque) total (celui des arbres de plus de 120)
for (i in 1:nrow(gha_ess)){
ogf <- gha_ess$ues_id_ogf[i]
ue <- gha_ess$ues_id_ue[i]
gha_ess$ess[i]
gha_rel[gha_rel$ues_id_ogf==ogf & gha_rel$ues_id_ue==ue, gha_ess$ess[i]] <-  100*gha_ess$gha_rel[i]/dendro_arbre_vivant$basal_area_alive_thres120[dendro_arbre_vivant$ues_id_ogf==ogf & dendro_arbre_vivant$ues_id_ue==ue]
}
gha_rel$essmaj <- apply(gha_rel[,!colnames(gha_rel) %in% c(key_ue_cols,"essmaj")], 1, twoEssMaj)
# fusion de toutes ces données en une table dendro - group by UE
dendro1 <- merge(dendro_arbre_vivant,dendro_cohorte,by=key_ue_cols, all=T)
dendro2 <-  merge(dendro1,dendro_arbre_mort,by=key_ue_cols, all=T)
dendro3 <-  merge(dendro2,gha_rel[,c(key_ue_cols,"essmaj")],by=key_ue_cols, all=T)
dendro4 <-  merge(dendro3,dendro_FAS,by=key_ue_cols, all=T)
dendro <-  merge(dendro4,dendro_LIS,by=key_ue_cols, all=T)
dendro[is.na(dendro)] <- 0
#, _co pour cohorte = arbres sous le seuil d'inventaire de 120 de circ. _thres120 pour les arbres de la table arbres
dendro$number_of_trees <- dendro$number_of_trees_thres120 + dendro$number_of_trees_co
dendro$vol_alive <- dendro$vol_alive_thres120 + dendro$vol_alive_co
dendro$vol_deadw <- dendro$vol_dead_standing + dendro$vol_log_FAS + dendro$vol_log_LIS
dendro$basal_area_alive <- dendro$basal_area_alive_thres120 + dendro$basal_area_alive_co
# circonférence dominante: je prends les 5 plus gros arbres
nDomTree <- 5
for (i in 1:nrow(dendro)){
cond <- which(arbre$ues_id_ogf==dendro$ues_id_ogf[i] & arbre$ues_id_ue==dendro$ues_id_ue[i] & arbre$statut==1)
c <-  sort(arbre[cond,"circ"], decreasing=T)
dendro$cdom[i] <- mean(c[1:min(nDomTree,length(c))])
}
dendro$pct_vol_dead_standing <- 100*dendro$vol_dead_standing/(dendro$vol_alive+dendro$vol_dead_standing)
dbWriteTable(db,"dendro",dendro, overwrite=T)
dendro$cdom[i]
dbWriteTable(db,"dendro",dendro, overwrite=T)
dbWriteTable(db,"dendro",dendro, overwrite=T)
summary(dendro)
plot <- read.csv2("/home/jo/Documents/OGF/FLANDERS_stat_per_UE/plotinfo.csv")
plot_dendro <- read.csv2("/home/jo/Documents/OGF/FLANDERS_stat_per_UE/plotlevel_data/dendro_by_plot.csv")
sub_dendro <- plot_dendro[plot_dendro$plot_id %in% plot$plot_id[plot$forest_reserve=="Kersselaerspleyn"] & plot_dendro$year==2020,]
sub_plot <- plot[plot$forest_reserve=="Kersselaerspleyn" & plot$period==3,]
fl1 <- cbind(sub_plot,sub_dendro)
write.csv2(fl1,"/home/jo/Documents/OGF/FLANDERS_stat_per_UE/Kersselaerspleyn_dendro.csv",row.names =FALSE)
sub_dendro <- plot_dendro[plot_dendro$year==2020,]
sub_dendro <- plot_dendro[plot_dendro$year==2020,]
summary(sub_dendro)
summary(sub_dendro$vol_dead_standing_m3_ha)
summary(dendro$vol_dead_standing)
summary(sub_dendro$vol_log_m3_ha
summary(dendro$vol_log_FAS)
summary(dendro$vol_log_FAS)
